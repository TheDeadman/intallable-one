/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();
self.skipWaiting();


// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
// const manifest = self.__WB_MANIFEST
precacheAndRoute(self.__WB_MANIFEST);


// Any other custom service worker logic can go here.
self.addEventListener('fetch', (e) => {
  console.log("FETCHED?", e)
  if ((e.request.url.indexOf('receive-shares') !== -1) && (e.request.method === 'GET')) {
    console.log("testing", e);
    return e.respondWith((async () => {
      const response = new Response(null, { url: 'http://localhost:3001' });
      return response;
    })())
    // e.request.url = 'http://localhost:3001'
    // return response;

    // return e.respondWith((() => {
    //   console.log("in the respond with?")
    //   // Store the URL, process it, communicate it to the clients…
    //   // You need to redirect the user somewhere, since the path
    //   // /receive-shares does not actually exist.
    //   return Response.redirect('/receive-shares', '304');
    //   // return Response.redirect('/#test', '304');
    // })())
  } else {
    console.log("IN THE ELSE", e)
    return e
  }
  /* Your regular fetch handler */
})

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');

// registerRoute(
//   // Return false to exempt requests from being fulfilled by index.html.
//   (e) => {
//     console.log(e)
//     return true;
//   },
//   createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// );

// registerRoute(
//   // Return false to exempt requests from being fulfilled by index.html.
//   ({ request, url }) => {
//     console.log()
//     // If this isn't a navigation, skip.
//     if (request.mode !== 'navigate') {
//       return false;
//     } // If this is a URL that starts with /_, skip.

//     if (url.pathname.startsWith('/_')) {
//       return false;
//     } // If this looks like a URL for a resource, because it contains // a file extension, skip.

//     if (url.pathname.match(fileExtensionRegexp)) {
//       return false;
//     } // Return true to signal that we want to use the handler.

//     return true;
//   },
createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// );

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => {
    console.log("IN THE REG ROUTE?")
    return url.origin === self.location.origin && url.pathname.endsWith('.png')
  }, // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);


// /* eslint-disable no-restricted-globals */

// // This service worker can be customized!
// // See https://developers.google.com/web/tools/workbox/modules
// // for the list of available Workbox modules, or add any other
// // code you'd like.
// // You can also remove this file if you'd prefer not to use a
// // service worker, and the Workbox build step will be skipped.

// import { clientsClaim } from 'workbox-core';
// import { ExpirationPlugin } from 'workbox-expiration';
// import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
// import { registerRoute } from 'workbox-routing';
// import { StaleWhileRevalidate } from 'workbox-strategies';

// clientsClaim();
// self.skipWaiting();


// // Precache all of the assets generated by your build process.
// // Their URLs are injected into the manifest variable below.
// // This variable must be present somewhere in your service worker file,
// // even if you decide not to use precaching. See https://cra.link/PWA
// // const manifest = self.__WB_MANIFEST
// precacheAndRoute(self.__WB_MANIFEST);


// // Any other custom service worker logic can go here.
// self.addEventListener('fetch', (e) => {
//   console.log("FETCHED?", e)
//   if ((e.request.url.indexOf('receive-shares') !== -1) && (e.request.method === 'GET')) {
//     console.log("testing", e);
//     e.preventDefault();
//     e.request.url = 'http://localhost:3001'
//     const newE = { ...e, request: { ...e.request, url: 'http://localhost:3001' } }
//     return newE;
//     // return e.respondWith((() => {
//     //   console.log("in the respond with?")
//     //   // Store the URL, process it, communicate it to the clients…
//     //   // You need to redirect the user somewhere, since the path
//     //   // /receive-shares does not actually exist.
//     //   return Response.redirect('/', 303);
//     // })())
//   } else {
//     return e
//   }
//   /* Your regular fetch handler */
// })

// // Set up App Shell-style routing, so that all navigation requests
// // are fulfilled with your index.html shell. Learn more at
// // https://developers.google.com/web/fundamentals/architecture/app-shell
// const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');

// // registerRoute(
// //   // Return false to exempt requests from being fulfilled by index.html.
// //   (e) => {
// //     console.log(e)
// //     return true;
// //   },
// //   createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// // );

// // registerRoute(
// //   // Return false to exempt requests from being fulfilled by index.html.
// //   (e) => {
// //     console.log(e)

// //     if (e.request.url.indexOf("/receive-shares") !== -1) {
// //       return false;
// //     }

// //     // If this isn't a navigation, skip.
// //     if (e.request.mode !== 'navigate') {
// //       return false;
// //     } // If this is a URL that starts with /_, skip.

// //     if (e.url.pathname.startsWith('/_')) {
// //       return false;
// //     } // If this looks like a URL for a resource, because it contains // a file extension, skip.

// //     if (e.url.pathname.match(fileExtensionRegexp)) {
// //       return false;
// //     } // Return true to signal that we want to use the handler.

// //     return true;
// //   },
// //   createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// // );

// // registerRoute(
// //   // Return false to exempt requests from being fulfilled by index.html.
// //   ({ request, url }) => {
// //     console.log()
// //     // If this isn't a navigation, skip.
// //     if (request.mode !== 'navigate') {
// //       return false;
// //     } // If this is a URL that starts with /_, skip.

// //     if (url.pathname.startsWith('/_')) {
// //       return false;
// //     } // If this looks like a URL for a resource, because it contains // a file extension, skip.

// //     if (url.pathname.match(fileExtensionRegexp)) {
// //       return false;
// //     } // Return true to signal that we want to use the handler.

// //     return true;
// //   },
// //   createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
// // );

// // An example runtime caching route for requests that aren't handled by the
// // precache, in this case same-origin .png requests like those from in public/
// // registerRoute(
// //   // Add in any other file extensions or routing criteria as needed.
// //   ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
// //   new StaleWhileRevalidate({
// //     cacheName: 'images',
// //     plugins: [
// //       // Ensure that once this runtime cache reaches a maximum size the
// //       // least-recently used images are removed.
// //       new ExpirationPlugin({ maxEntries: 50 }),
// //     ],
// //   })
// // );
